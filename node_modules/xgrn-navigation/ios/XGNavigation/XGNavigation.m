//
//  XGNavigation.m
//  routedemo
//
//  Created by nuomi on 2018/1/22.
//  Copyright © 2018年 Facebook. All rights reserved.
//

#import "XGNavigation.h"
#import <React/RCTBridgeModule.h>
#import "XGNavigationMacro.h"
#import "XGRNPageController.h"
#import "XGRNTabBarController.h"
#import "UINavigationController+XGRoute.h"
#import "UIView+XGCallBack.h"
#import "UIViewController+XGRoute.h"
#import <objc/runtime.h>
#import "XGTransitionModel.h"
#import "LaunchPlaceHolder.h"
#import "RCTNavigationEmitter.h"
#import "XGRNViewFactory.h"
#import "XGRNViewFactory.h"
// 页面类型
NSString * const XG_JSPage = @"JSPage";
NSString * const XG_NativePage = @"NativePage";
NSString * const XG_NativeTabPage = @"NativeTabPage";
// 转场动画类型
NSString * const XG_TransitionFromBottom = @"FromBottom";
NSString * const XG_TransitionFromRight = @"FromRight";

UINavigationController * GetWindowRootNavigationVC()
{
    UIViewController * rootVC = [UIApplication sharedApplication].keyWindow.rootViewController;
    UINavigationController * rootNavigationVC = nil;
    if (rootVC && [rootVC isKindOfClass:[UINavigationController class]]){
        rootNavigationVC = (UINavigationController *)rootVC;
    } else {
        NSLog(@"GetWindowRootNavigationVC 异常 , 请检查window根控制器是否为UINavigationController");
    }
    return rootNavigationVC;
}

static NSMutableDictionary  *XGAlertStack;
// 添加view
void XGAddAlert(NSString * alertId, UIView * view)
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        XGAlertStack = [NSMutableDictionary dictionary];
    });
    [XGAlertStack setObject:view forKey:alertId];
}

// 移除view
void XGRemoveAlert(NSString * alertId)
{
    if (XGSafeDictionary(XGAlertStack)) {
        UIView * view = XGAlertStack[alertId];
        if (!view) return;
        if (view.xg_callBackArr && view.xg_callBackArr.count) {
            NSArray * tmpArr = [NSArray arrayWithArray:view.xg_callBackArr];
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                for (NSString * callBackID in tmpArr) {
                    [RCTNavigationEmitter unregisterCallBackBy:callBackID];
                }
            });
        }
        [view removeFromSuperview];
        [XGAlertStack removeObjectForKey:alertId];
        view = nil;
    }
}


@interface XGNavigation() <RCTBridgeModule>
@end

@implementation XGNavigation

RCT_EXPORT_MODULE()

#pragma mark - 重置路由栈
RCT_EXPORT_METHOD(resetRoot:(NSDictionary *)pageConfig andAnimated:(BOOL)animate and:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [XGNavigation resetRoot:pageConfig andAnimated:animate andComplete:^{
        resolve(@YES);
    }];
}

#pragma mark - push页面
RCT_EXPORT_METHOD(push:(NSDictionary *)pageConfig andAnimated:(BOOL)animated)
{
    [XGNavigation push:pageConfig andAnimated:animated];
}

#pragma mark - 替换路由栈顶route
RCT_EXPORT_METHOD(replaceStackTopRoute:(NSDictionary *)pageConfig andAnimated:(BOOL)animated){
    [XGNavigation replaceStackTopRoute:pageConfig andAnimated:animated];
}

#pragma mark - 从路由栈中移除某个页面
RCT_EXPORT_METHOD(removeRoute:(NSDictionary *)route)
{
    // 查看当前页面是否处于tab内部，如果处理tab内部，删除tab页面
    NSInteger index = [(XGSafeDictionary(route) ? route : @{})[@"index"] integerValue];
    void(^actionBlock)() = ^(){
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        NSMutableArray * arrStack = [NSMutableArray arrayWithArray:rootNavigationVC.viewControllers];
        [arrStack removeObjectAtIndex:index];
        [rootNavigationVC setViewControllers:arrStack];
    };
    xg_dispatch_main_async_safe(^{
        actionBlock();
    });
    
}

#pragma mark - 获取路由栈
RCT_EXPORT_METHOD(getRouteStack:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject){
    xg_dispatch_main_async_safe(^{
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        resolve(rootNavigationVC.routeStack);
    });
}

#pragma mark - push页面
RCT_EXPORT_METHOD(setTabBarSelectedIndex:(NSDictionary *)route andNewIndex:(NSInteger)newIndex)
{
    route = XGSafeDictionary(route) ? route : @{};
    NSString * uniqueId = route[@"uniqueId"];
    if (XGSafeString(uniqueId)) {
        xg_dispatch_main_async_safe(^{
            [XGNavigation changeTabBarSelectedIndex:uniqueId andNewIndex:newIndex];
        });
    }
}

+ (void)changeTabBarSelectedIndex:(NSString *)uniqueId andNewIndex:(NSInteger)newIndex{
    UINavigationController * rootNaVC = GetWindowRootNavigationVC();
    for (UIViewController * vc in rootNaVC.viewControllers) {
        // 从栈中所有TabBarVC里面查询是否存在
        if ([vc isKindOfClass:[UITabBarController class]]) {
            UITabBarController * tabBar = (UITabBarController *)vc;
            if ([uniqueId isEqualToString:tabBar.uniqueId]) {
                tabBar.selectedIndex = newIndex;
                break;
            }
            if (newIndex > tabBar.viewControllers.count - 1) {
                break;
            }
            for (UIViewController * tabVC in tabBar.viewControllers) {
                if ([uniqueId isEqualToString:tabVC.uniqueId]) {
                    tabBar.selectedIndex = newIndex;
                    return ;
                }
            }
        }
    }
}


RCT_EXPORT_METHOD(setTabBarItemBadgeValue:(NSDictionary *)tabRoute andIndex:(nonnull NSNumber * )index andBadgeValue:(NSString *)badgeValue)
{
    xg_dispatch_main_async_safe(^{
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        for (UIViewController * vc in rootNavigationVC.viewControllers) {
            UITabBarController * tabVC = nil;
            if ([vc isKindOfClass:[UITabBarController class]]) {
                tabVC = (UITabBarController *)vc;
            } else {
                tabVC = vc.tabBarController;
            }
            if (tabVC && [tabVC.uniqueId isEqualToString:tabRoute[@"uniqueId"]] && tabVC.viewControllers && tabVC.viewControllers.count >= [index integerValue] + 1) {
                UIViewController * vc = tabVC.viewControllers[[index integerValue]];
                if (XGSafeString(badgeValue) && ![badgeValue isEqualToString:@"0"]) {
                    vc.tabBarItem.badgeValue = badgeValue;
                } else {
                    vc.tabBarItem.badgeValue = nil;
                }
                break;
            }
        }
    });
}

#pragma mark - 返回一层
RCT_EXPORT_METHOD(pop:(BOOL)animated)
{
    xg_dispatch_main_async_safe(^{
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        if (rootNavigationVC) {
            [rootNavigationVC popViewControllerAnimated:animated];
        }
    });
}

#pragma mark - 返回到指定路由
RCT_EXPORT_METHOD(popToRoute:(NSDictionary *)stack andAnimated:(BOOL)animated)
{
    [XGNavigation popToRoute:stack andAnimated:animated];
}


#pragma mark - 根据该路由是否处于tab容器里面
RCT_EXPORT_METHOD(isChildTab:(NSDictionary *)route andResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    route = XGSafeDictionary(route)?route:@{};
    NSString * uniqueId = route[@"uniqueId"];
    xg_dispatch_main_async_safe(^{
        NSArray * routeStack = GetWindowRootNavigationVC().routeStack;
        BOOL isChildTabVC = NO;
        if (!XGSafeString(uniqueId)) {
            resolve(@(isChildTabVC));
            return;
        }
        for (NSDictionary * itemRoute in routeStack) {
            NSString * pageType = itemRoute[@"pageType"];//页面类型
            NSArray * tabs = itemRoute[@"tabs"]?:@[];//子vc
            //Tab页面，遍历子
            if([XG_NativeTabPage isEqualToString:pageType]){
                for (NSDictionary * item in tabs) {
                    NSString * itemUniqueId = item[@"uniqueId"];
                    if (XGSafeString(itemUniqueId) && [itemUniqueId isEqualToString:uniqueId]) {
                        isChildTabVC = YES;
                    }
                }
            }
        }
        resolve(@(isChildTabVC));
    });
}

#pragma mark - 返回到栈底
RCT_EXPORT_METHOD(popToRoot:(BOOL)animated)
{
    xg_dispatch_main_async_safe(^{
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        if(rootNavigationVC){
            [rootNavigationVC popToRootViewControllerAnimated:animated];
        }
    });
}

#pragma mark - 展示启动占位图
RCT_EXPORT_METHOD(showLaunchImageOnWindow)
{
    [LaunchPlaceHolder showLaunchImageOnWindow];
}


#pragma mark - 移除启动占位图
RCT_EXPORT_METHOD(removeLaunchImageFromWindow)
{
    [LaunchPlaceHolder removeLaunchImageFromWindow];
}


#pragma mark - 是否开启侧滑手势
RCT_EXPORT_METHOD(allowPopGestureRecognizer:(NSDictionary *)route andAllowPopGesture:(BOOL)allow)
{
    if (!XGSafeDictionary(route)) {
        return;
    }
    void(^actionBlcok)() = ^{
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        for (UIViewController * vc in rootNavigationVC.viewControllers?:@[]) {
            if ([vc.route isEqualToDictionary:route]) {
                vc.allowPopGestureRecognizer = [NSNumber numberWithBool:allow];
                break ;
            }
            if ([vc isKindOfClass:[XGRNTabBarController class]]) {
                XGRNTabBarController * tabBarVC = (XGRNTabBarController *)vc;
                for (UIViewController * tabChildVC in tabBarVC.viewControllers?:@[]) {
                    if ([tabChildVC.route isEqualToDictionary:route]) {
                        tabChildVC.allowPopGestureRecognizer = [NSNumber numberWithBool:allow];
                        return ;
                    }
                }
            }
        }
    };
    xg_dispatch_main_async_safe(^{
        actionBlcok();
    });
}

/*------------------------------分割线--------------------------------------*/

+ (void)replaceStackTopRoute:(NSDictionary *)pageConfig andAnimated:(BOOL)animated{
    void(^replaceBlock)() = ^(){
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        UIViewController * topVC = rootNavigationVC.viewControllers[rootNavigationVC.viewControllers.count - 1];
        UIViewController * newVc = [self getViewControllerBy:pageConfig];
        if (animated) {
            [rootNavigationVC pushViewController:newVc animated:YES];
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.35 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                NSArray * vcArray = rootNavigationVC.viewControllers;
                NSMutableArray * arr = [NSMutableArray arrayWithArray:vcArray];
                [arr removeObject:topVC];
                rootNavigationVC.viewControllers = arr;
            });
        } else {
            NSArray * vcArray = rootNavigationVC.viewControllers;
            NSMutableArray * arr = [NSMutableArray arrayWithArray:vcArray];
            [arr removeObject:topVC];
            [arr addObject:newVc];
            rootNavigationVC.viewControllers = arr;
        }
    };
    xg_dispatch_main_async_safe(^{
        replaceBlock();
    });
}

+ (void)push:(NSDictionary *)pageConfig andAnimated:(BOOL)animated{
    
    void(^pushBlock)() = ^(){
        UINavigationController * rootNavigationVC = GetWindowRootNavigationVC();
        UIViewController * vc = [self getViewControllerBy:pageConfig];
        if (vc && rootNavigationVC) {
            NSString * transitionsConfig = pageConfig[@"transitionsConfig"];
            if (XGSafeString(transitionsConfig) && [XG_TransitionFromBottom isEqualToString:transitionsConfig]) {
                XGTransitionModel *model = [[XGTransitionModel alloc] init];
                model.transitionType = XGTransitionShowFromBottom;
                vc.allowPopGestureRecognizer = @NO;
                vc.transitionModel = model;
                rootNavigationVC.delegate = model;
            }
            [rootNavigationVC pushViewController:vc animated:animated];
            rootNavigationVC.delegate = nil;
        } else {
            NSLog(@"找不到该页面:%@",pageConfig);
        }
    };
    xg_dispatch_main_async_safe(^{
        pushBlock();
    });
}

+ (void)popToRoute:(NSDictionary *)route andAnimated:(BOOL)animated{
    route = XGSafeDictionary(route)?route:@{};
    NSString * uniqueId = route[@"uniqueId"];
    if (!XGSafeString(uniqueId)) {
        return;
    }
    xg_dispatch_main_async_safe(^{
        [self popToRouteWith:uniqueId andAnimated:animated];
    });
}

// 返回栈
+ (void)popToRouteWith:(NSString *)uniqueId andAnimated:(BOOL)animated{
    UINavigationController * rootNaVC = GetWindowRootNavigationVC();
    for (UIViewController * vc in rootNaVC.viewControllers) {
        //先从栈中寻找是否存在
        if ([uniqueId isEqualToString:vc.uniqueId]) {
            [rootNaVC popToViewController:vc animated:animated];
            return;
        }
        // 从TabBarVC里面查询是否存在
        if ([vc isKindOfClass:[UITabBarController class]]) {
            UITabBarController * tabBar = (UITabBarController *)vc;
            for (UIViewController * tabVC in tabBar.viewControllers) {
                if ([uniqueId isEqualToString:tabVC.uniqueId]) {
                    [rootNaVC popToViewController:tabBar animated:animated];
                    return;
                }
            }
        }
    }
}

+ (void)resetRoot:(nonnull NSDictionary *)pageConfig andAnimated:(BOOL)animated{
    [self resetRoot:pageConfig andAnimated:animated andComplete:nil];
}

+ (void)resetRoot:(nonnull NSDictionary *)pageConfig andAnimated:(BOOL)animated andComplete:(CompleteBlock)completeBlock{
    xg_dispatch_main_async_safe(^{
        // find root navigation vc and create vc by pageConfig ,then reset
        [LaunchPlaceHolder removeLaunchImageFromWindow];
        UINavigationController *  rootNavigationVC = GetWindowRootNavigationVC();
        UIViewController * vc = [self getViewControllerBy:pageConfig];
        if (rootNavigationVC && vc) {
            [rootNavigationVC setViewControllers:@[vc] animated:animated];
        }
        if (!animated) {
            if (completeBlock) {
                completeBlock();
            }
        } else {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                if (completeBlock) {
                    completeBlock();
                }
            });
        }
    });
}


#pragma mark - 根据配置获取对应类型的ViewController，
+ (UIViewController *)getViewControllerBy:(NSDictionary *)pageConfig{
    
    // prase value
    pageConfig = pageConfig?:@{};
    NSString * pageType = pageConfig[@"pageType"];//页面类型
    NSString * pagePath = pageConfig[@"pagePath"];//页面路径
    NSString * uniqueId = XGSafeString(pageConfig[@"uniqueId"])?pageConfig[@"uniqueId"]:[[NSUUID  UUID] UUIDString];//页面唯一id
    NSDictionary * params = pageConfig[@"params"];//页面初始化参数
    NSDictionary * tabConfigs = pageConfig[@"tabConfigs"];//tab栏配置
    
    // checkout require key-value
    if (!XGSafeString(pageType)) {
        NSLog(@"warn: YOU MAY MISS pageType : %@",pageConfig);
        return nil;
    }
    if (!XGSafeString(pagePath)) {
        NSLog(@"warn: YOU MAY MISS pagePath : %@",pageConfig);
        return nil;
    }
    
    UIViewController * viewController = nil;
    if ([XG_JSPage isEqualToString:pageType]){
        XGRNPageController * rnVC = [[XGRNPageController alloc] init];
        NSMutableDictionary * transformPageConfig = [NSMutableDictionary dictionaryWithDictionary:pageConfig];
        NSMutableArray * callBackArr = [NSMutableArray array];
        if (XGSafeDictionary(params)) {
            for (NSString * key in params.allKeys) {
                id value = params[key];
                NSString * type = NSStringFromClass([value class]);
                // 如果传递的参数是block类型，转换
                if ([type isEqualToString:@"__NSGlobalBlock__"] || [type isEqualToString:@"__NSMallocBlock__"] || [type isEqualToString:@"__NSStackBlock__"]) {
                    NSMutableDictionary * tmpParams = [NSMutableDictionary dictionaryWithDictionary:params];
                    NSString * callBackID = [key stringByAppendingString:[[NSUUID UUID] UUIDString]];
                    [tmpParams setObject:@{
                                           @"callBackID": callBackID,
                                           @"valueType": @"function"
                                           } forKey:key];
                    [transformPageConfig setObject:tmpParams forKey:@"params"];
                    // 原声跳转js的时候，设置了
                    JSCallBackBlock callBack = value;
                    [RCTNavigationEmitter registerCallBackBy:callBackID andCallBack:callBack];
                    [callBackArr addObject:callBackID];
                }
            }
        }
        rnVC.pageConfig = transformPageConfig;
        if (callBackArr && callBackArr.count) {
            rnVC.xg_callBackArr = callBackArr;
        }
        viewController = rnVC;
        
    } else if([XG_NativeTabPage isEqualToString:pageType]){
        XGRNTabBarController * tabBarVC= [[XGRNTabBarController alloc] init];
        if(!XGSafeDictionary(tabConfigs)){
            NSLog(@"warn: YOU MAY MISS tabConfigs,when pageType === %@ : %@",XG_NativeTabPage,pageConfig);
            return nil;
        }
        tabBarVC.tabConfigs = tabConfigs;
        tabBarVC.pagePath = pagePath;
        viewController = tabBarVC;
    } else if ([XG_NativePage isEqualToString:pageType]){
        UIViewController * vc = [[NSClassFromString(pagePath) alloc] init];
        if (!vc) {
            NSLog(@"warn: Can`t find Class with %@ \n Check your pageConfig:%@",pagePath,pageConfig);
            return nil;
        }
        if (XGSafeDictionary(params) && params.allKeys.count) {
            for (NSString * key in params.allKeys) {
                @try{
                    //use KVC to set params dynamically, when key define readonly, KVC will also set value for this key, so developer should pay attion to this features.
                    //there also be a defects, when you set wrong type for this key, maybe lead to a potential bug.
                    id value = params[key];
                    if (XGSafeDictionary(value) && XGSafeString(((NSDictionary *)value)[@"callBackID"]) &&  [@"function" isEqualToString:((NSDictionary *)value)[@"valueType"]]) {
                        // 如果是字典，且存在clickCallBack 且valueType是function 自动转换为block变量
                        [vc setValue:^(NSDictionary * info){
                            [[NSNotificationCenter defaultCenter] postNotificationName:@"XGNavigationNotification" object:@{
                                                                                                                            @"callBackID": ((NSDictionary *)value)[@"callBackID"],
                                                                                                                            @"params":info?:[NSNull null]
                                                                                                                            }];
                        } forKey:key];
                    } else {
                        [vc setValue:params[key] forKey:key];
                    }
                }@catch(NSException * exception){
                    NSLog(@"Error: %@ You must set wrong value for keyPath or key not define :\nkey-->%@\nvalue-->%@ \nexception:%@ \n %@",pagePath,key,params[key],exception,pageConfig);
                }
            }
        }
        viewController = vc;
    } else {
        NSLog(@"warn: not support pageType: %@, only JSPage-NativeTabPage-NativePage",pageType);
    }
    viewController.pagePath = pagePath;
    viewController.pageType = pageType;
    viewController.uniqueId = uniqueId;
    return viewController;
}

/*----------ALERT---------*/
RCT_EXPORT_METHOD(alert:(NSDictionary *)alertConfig){
    [[self class] xg_Alert:alertConfig];
}

RCT_EXPORT_METHOD(alertIsShow:(NSString *)alertId and:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject){
    BOOL isShow = [[self class] xg_alertIsShow:alertId];
    resolve([NSNumber numberWithBool:isShow]);
}

RCT_EXPORT_METHOD(removeAlert:(NSString *)alertId){
    if (!XGSafeString(alertId)) return;
    xg_dispatch_main_async_safe(^{
        XGRemoveAlert(alertId);
    });
}

+ (BOOL)xg_alertIsShow:(NSString *)alertId{
    if (!XGSafeString(alertId)) return NO;
    UIView * view = XGAlertStack[alertId];
    if (view) {
        return YES;
    } else {
        return NO;
    }
}

+ (void)xg_removeAlert:(NSString *)alertId{
    if (!XGSafeString(alertId)) return;
    xg_dispatch_main_async_safe(^{
        XGRemoveAlert(alertId);
    });
}

+ (NSString *)xg_Alert:(NSDictionary *)originAlertConfig{
    NSMutableDictionary * alertConfig = [NSMutableDictionary dictionaryWithDictionary:originAlertConfig];
    NSString * alertPath = alertConfig[@"alertPath"];
    NSString * alertId = alertConfig[@"alertId"];
    if (!XGSafeString(alertId)) { // 原声调用的时候，并不存在alertID
        alertId = [[NSUUID UUID] UUIDString];
        [alertConfig setObject:alertId forKey:@"alertId"];
    }
    NSMutableArray * callBackArr = [NSMutableArray array];
    NSDictionary * params = alertConfig[@"params"]?:@{};
    for (NSString * key in params) {
        // 如果
        id value = params[key];
        NSString * type = NSStringFromClass([value class]);
        // 如果传递的参数是block类型，转换
        if ([type isEqualToString:@"__NSGlobalBlock__"] || [type isEqualToString:@"__NSMallocBlock__"] || [type isEqualToString:@"__NSStackBlock__"]) {
            NSMutableDictionary * tmpParams = [NSMutableDictionary dictionaryWithDictionary:params];
            NSString * callBackID = [key stringByAppendingString:[[NSUUID UUID] UUIDString]];
            [tmpParams setObject:@{
                                   @"callBackID": callBackID,
                                   @"valueType": @"function"
                                   } forKey:key];
            [alertConfig setObject:tmpParams forKey:@"params"];
            JSCallBackBlock callBack = value;
            [RCTNavigationEmitter registerCallBackBy:callBackID andCallBack:callBack];
            [callBackArr addObject:callBackID];
        }
    }
    NSString * level = alertConfig[@"level"];
    NSDictionary * bindRoute = alertConfig[@"bindRoute"];
    if (!XGSafeString(alertPath)) {
        return nil;
    }
    void(^alertBlock)() = ^(){
        UIView * view = [XGRNViewFactory getAlertByConfig:alertConfig];
        if (callBackArr.count) {
            view.xg_callBackArr = callBackArr;
        }
//        view.userInteractionEnabled = NO;
        view.backgroundColor = [UIColor clearColor];
        view.frame = [UIScreen mainScreen].bounds;
        XGAddAlert(alertId,view);
        if ([level isEqualToString:@"PageLevel"] && XGSafeDictionary(bindRoute)) {
            NSString * uniqueId = bindRoute[@"uniqueId"];
            if (!XGSafeString(uniqueId)) {
                return ;
            }
            // 添加到bindRoute页面上
            UINavigationController *  rootNavigationVC = GetWindowRootNavigationVC();
            for (UIViewController * vc in rootNavigationVC.viewControllers) {
                if ([vc.uniqueId isEqualToString:uniqueId]) {//
                    if (vc.tabBarController) {
                        [vc.tabBarController.view addSubview:view];
                        break;
                    } else {
                        [vc.view addSubview:view];
                        break;
                    }
                } else if([vc isKindOfClass:[UITabBarController class]]){
                    UITabBarController * tabVC = (UITabBarController *)vc;
                    for (UIViewController * childTab in tabVC.viewControllers) {
                        if ([childTab.uniqueId isEqualToString:uniqueId]) {
                            [childTab.tabBarController.view addSubview:view];
                            return;
                        }
                    }
                }
            }
        } else if([level isEqualToString:@"NavigationLevel"]){
            // 添加
            UINavigationController *  rootNavigationVC = GetWindowRootNavigationVC();
            [rootNavigationVC.view addSubview:view];
        } else if([level isEqualToString:@"WindowLevel"]){
            [[UIApplication sharedApplication].keyWindow addSubview:view];
        } else {
            XGRemoveAlert(alertId);
        }
    };
    
    xg_dispatch_main_async_safe(^{
        alertBlock();
    });
    return alertId;
}


@end

