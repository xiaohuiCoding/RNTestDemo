//
//  XGRNBridgeManager.m
//  XGNavigation
//
//  Created by nuomi on 2018/3/6.
//  Copyright © 2018年 demo. All rights reserved.
//

#import "XGRNBridgeManager.h"
#import <React/RCTRootView.h>
#import <React/RCTBundleURLProvider.h>

@interface XGRNBridgeManager ()

@property (nonatomic,strong) RCTBridge * bridge;//共享bridge

@end

@implementation XGRNBridgeManager

static XGRNBridgeManager *_singleton;

+ (instancetype)standardManager{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _singleton = [[self alloc] init];;
    });
    return _singleton;
}

+ (instancetype)allocWithZone:(struct _NSZone *)zone{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _singleton = [super allocWithZone:zone];
    });
    return _singleton;
}

#pragma mark - loading jsbunlde, and create common bridge
- (void)loadBridgeWithBundleURL:(NSURL *)url andModuleName:(NSString *)moduleName launchOptions:(NSDictionary *)launchOptions{
    
    //  NSDictionary * userInfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];
    //  NSMutableDictionary * initialProperties = [NSMutableDictionary dictionaryWithDictionary:userInfo];
    //  [initialProperties setObject:@"background" forKey:@"appState"];
    _moduleName = moduleName;
    _launchOptions = launchOptions;
    _bridge = [[RCTBridge alloc] initWithBundleURL:url
                                    moduleProvider:nil
                                     launchOptions:launchOptions];
    
}

#pragma mark - loading jsbunlde
// todo 通知外部进行相关的内存释放，以及重新通知路由进行包加载。
- (void)reLoadBridgeWithBundleURL:(NSURL *)url andModuleName:(NSString *)moduleName launchOptions:(NSDictionary *)launchOptions{
    _moduleName = moduleName;
    _launchOptions = launchOptions;
    _bridge = [[RCTBridge alloc] initWithBundleURL:url
                                    moduleProvider:nil
                                     launchOptions:launchOptions];
}

- (RCTBridge *)getCommonBridge{
    return self.bridge;
}

//- (instancetype)init
//{
//  self = [super init];
//  if (self) {
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(RCTJavaScriptWillStartLoadingNotification) name:RCTJavaScriptWillStartLoadingNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(RCTJavaScriptDidLoadNotification) name:RCTJavaScriptDidLoadNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(RCTJavaScriptDidFailToLoadNotification) name:RCTJavaScriptDidFailToLoadNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(RCTDidInitializeModuleNotification) name:RCTDidInitializeModuleNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(RCTBridgeWillDownloadScriptNotification) name:RCTBridgeWillDownloadScriptNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(RCTBridgeDidDownloadScriptNotification) name:RCTBridgeDidDownloadScriptNotification object:nil];
//  }
//  return self;
//}
//
//#pragma mark - JavaScriptCodeLoad Notification
//
///**
// * This notification fires when the bridge starts loading the JS bundle.
// */
//- (void)RCTJavaScriptWillStartLoadingNotification{
//  NSLog(@"RCTJavaScriptWillStartLoadingNotification");
//}
//
///**
// * This notification fires when the bridge has finished loading the JS bundle.
// */
//- (void)RCTJavaScriptDidLoadNotification{
//  NSLog(@"RCTJavaScriptDidLoadNotification");
//}
//
///**
// * This notification fires when the bridge failed to load the JS bundle. The
// * `error` key can be used to determine the error that occured.
// */
//- (void)RCTJavaScriptDidFailToLoadNotification{
//  NSLog(@"RCTJavaScriptDidFailToLoadNotification");
//}
//
///**
// * This notification fires each time a native module is instantiated. The
// * `module` key will contain a reference to the newly-created module instance.
// * Note that this notification may be fired before the module is available via
// * the `[bridge moduleForClass:]` method.
// */
//- (void)RCTDidInitializeModuleNotification{
//  NSLog(@"RCTDidInitializeModuleNotification");
//}
//
///**
// * This notification fires just before the bridge starts processing a request to
// * reload.
// */
//- (void)RCTBridgeWillDownloadScriptNotification{
//  NSLog(@"RCTBridgeWillDownloadScriptNotification");
//}
//
//
///**
// * This notification fires just before the bridge begins downloading a script
// * from the packager.
// */
//- (void)RCTBridgeDidDownloadScriptNotification{
//  NSLog(@"RCTBridgeDidDownloadScriptNotification");
//}



-(void)dealloc{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

@end
