package com.xinguang.imaglib.cycleImage.cycle;

import android.content.Context;
import android.os.Handler;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 传感器管理
 * 1、 通过viewpager当前是否是视频   是否是大屏显示
 * 2、负责角度的处理与发送
 * 有参的初始化  为了后面方便获得对象 需要先调用初始化 init 方法
 *
 * @author wl on 2017/9/6 0006 14:43
 */

public class ScreenSwitchManager extends BaseToObserve<ScreenSwitchManager.VideoAnglesUtils>
        implements CycleViewZoomManager.UpVideo, ScreenSwitchUtils.AngleToMonitor {
    private ScreenSwitchUtils screenSwitchUtils;
    private static ScreenSwitchManager screenSwitchManager;
    private Handler handler;
    private boolean largeScreenStatr, showVideoState;
    private int currAngles;//当前角度

    private ScreenSwitchManager(Context context) {
        super();
        handler = new Handler();
        screenSwitchUtils = ScreenSwitchUtils.init(context);
        screenSwitchUtils.addAngleToMonitor(this);
        CycleViewZoomManager.getInstance().addObserve(this);
    }

    public static ScreenSwitchManager getInstance() {

        return screenSwitchManager;
    }

    /**
     * 初始化
     */
    public static ScreenSwitchManager init(Context c) {
        return screenSwitchManager = new ScreenSwitchManager(c);
    }

    /**
     * 想它反映，现在是否是大屏显示状态
     */
    public void setLargeScreenState(boolean largeScreenStatr) {
        this.largeScreenStatr = largeScreenStatr;
        //当小屏时，必须是0度
        setAnglesa(0);
        judgmentOn();
    }

    /**
     * 想它反映，现在是否是显示的视频
     */
    public void setShowVideoState(boolean showVideoState) {
        this.showVideoState = showVideoState;
        judgmentOn();
    }

    private void judgmentOn() {
        if (largeScreenStatr && showVideoState) {
            screenSwitchUtils.start();
        } else {
            screenSwitchUtils.stop();
        }
    }

    @Override
    public void upMin() {
        setLargeScreenState(false);
    }

    @Override
    public void upMax() {
        setLargeScreenState(true);
    }

    @Override
    public void upPosition(int position) {

    }

    /**
     * 退出前台时，不要传感器了
     */
    public void stop() {
        screenSwitchUtils.stop();
    }

    long lastTtime;

    /**
     * 接收来自 传感器的信息 进行判断
     */
    @Override
    public void setAngles(int angles) {
        if (cd()) return;//不是全屏不操作
        if (angles > 70 && angles < 110) {
            setAnglesa(-90);
        } else if (angles > 250 && angles < 290) {
            setAnglesa(90);
        } else {
            setAnglesa(0);
        }
    }

    /**
     * 分给每一个注册的
     */
    private void setAnglesa(final int angles) {
        currAngles = angles;
        //先通知activity
        if (videoAnglesUtils != null) {
            videoAnglesUtils.setAngles(angles);
        }
        //延迟推送
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        dispense(new DispenseUtil<VideoAnglesUtils>() {
                            @Override
                            public void theEvent(VideoAnglesUtils observe) {
                                observe.setAngles(angles);
                            }
                        });
                    }
                });
            }
        }, 500);
    }

    public interface VideoAnglesUtils {
        void setAngles(int angles);
    }

    /**
     * 避免频繁旋转  是否在冷却时间
     */
    private boolean cd() {
        long currTime = System.currentTimeMillis();
        if (currTime - lastTtime > 1 * 1000) {
            lastTtime = currTime;
            return false;
        } else {
            return true;
        }
    }

    private VideoAnglesUtils videoAnglesUtils;

    /**
     * activity的导航栏操作必须在视频旋转之前，特此正价一个单独的注册
     */
    public void setActivityObserve(VideoAnglesUtils v) {
        videoAnglesUtils = v;
    }
    //清除的方法也要重新

    @Override
    public void removeObserveAll() {
        super.removeObserveAll();
        videoAnglesUtils = null;
    }

    /**
     * 有一种情况  横屏时，back  需要切竖屏
     * 特此提供方法
     */
    public void setAnglesa0() {
        setAnglesa(0);
    }

    public int getCurrAngles() {
        return currAngles;
    }
}
