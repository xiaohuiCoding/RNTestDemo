package com.xg.navigation;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.ActivityOptionsCompat;
import android.support.v4.app.Fragment;
import android.text.TextUtils;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;

import com.facebook.react.ReactApplication;
import com.facebook.react.ReactInstanceManager;
import com.facebook.react.ReactRootView;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.xg.navigation.bridge.BundleConverter;
import com.xg.navigation.bridge.PromiseUtil;
import com.xg.navigation.constants.NavigationConstants;
import com.xg.navigation.delegates.NavigationDelegate;
import com.xg.navigation.delegates.ReactDelegate;
import com.xg.navigation.delegates.bottom.BaseBottomDelegate;
import com.xg.navigation.splash.SplashScreen;
import com.xg.navigation.util.NavigationUtil;
import com.xg.navigation.util.RxBus;
import com.xg.navigation.view.NavigationBottomDelegate;
import com.xg.navigation.view.ReactFragment;
import com.xg.navigation.view.ReactItem;
import com.xg.navigation.view.ReactItemContainer;

import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import io.reactivex.functions.Consumer;
import me.yokeyword.fragmentation.ExtraTransaction;
import me.yokeyword.fragmentation.ISupportFragment;
import me.yokeyword.fragmentation.SupportHelper;


@SuppressWarnings("unused")
public class ReactNavigationModule extends ReactContextBaseJavaModule {


    private static final String CALLBACK_ID = "callBackID";
    private static final String PARAMS = "params";
    private static final String CLICK_CALLBACK = "clickCallBack";

    private static final Set<String> callBackIDSet = new ConcurrentSkipListSet<>();

    private static final ScheduledExecutorService mExecutorService = Executors.newScheduledThreadPool(3);
    @SuppressWarnings("FieldCanBeLocal")
    private final String NAME = "XGNavigation";
    private static final String ACTIVITY_PARAMS_BUNDLE = "ACTIVITY_PARAMS_BUNDLE";

    private Promise mRootPromise;

    ReactNavigationModule(ReactApplicationContext reactContext) {
        super(reactContext);
        //注册事件
        RxBus.getInstance().register(Boolean.class).subscribe(new Consumer<Boolean>() {
            @Override
            public void accept(Boolean isComplete) throws Exception {
                if (mRootPromise!=null) {
                    mRootPromise.resolve(isComplete);
                    mRootPromise = null;
                }
            }
        }, new Consumer<Throwable>() {
            @Override
            public void accept(Throwable throwable) throws Exception {
                if (mRootPromise!=null) {
                    mRootPromise.resolve(false);
                    mRootPromise = null;
                }
            }
        });
    }

    @Override
    public String getName() {
        return NAME;
    }

    @ReactMethod
    public void resetRoot(final ReadableMap params, final boolean animated, Promise promise) {

        if (params == null) {
            return;
        }

        mRootPromise = promise;

        Intent intent = new Intent(NavigationApplication.instance, NavigationActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(ACTIVITY_PARAMS_BUNDLE, BundleConverter.toBundle(params));

        if (animated) {
            NavigationApplication.instance.startActivity(intent);
        } else {
            Bundle bundle = ActivityOptionsCompat.makeCustomAnimation(NavigationApplication.instance,
                    android.R.anim.fade_in,
                    android.R.anim.fade_out
            ).toBundle();
            NavigationApplication.instance.startActivity(intent, bundle);
        }
    }

    @ReactMethod
    public void push(final ReadableMap params, boolean animated) throws Exception {

        String pageType;
        String pagePath;
        String transitionsConfig;
        try {
            pageType = params.getString("pageType");
            pagePath = params.getString("pagePath");
            transitionsConfig = params.getString("transitionsConfig");
        } catch (Exception e) {
            return;
        }

        if (TextUtils.isEmpty(pageType) || TextUtils.isEmpty(pagePath)) {
            return;
        }

        switch (pageType) {
            case NavigationConstants.JS_PAGE: {
                ExtraTransaction extraTransaction = NavigationActivity.currentActivity.extraTransaction()
                        .setTag(pagePath);
                NavigationUtil.pushWithTransition(extraTransaction, transitionsConfig,
                        ReactFragment.newInstance(BundleConverter.toBundle(params)), animated, false);
                break;
            }
            case NavigationConstants.NATIVE_PAGE: {
                NavigationDelegate targetDelegate;
                try {
                    Class targetClass = Class.forName(pagePath);
                    targetDelegate = (NavigationDelegate) targetClass.newInstance();
                } catch (Exception e) {
                    e.printStackTrace();
                    return;
                }
                if (targetDelegate == null) {
                    return;
                }
                // processJsToNativeBundle(bundle);
                Bundle bundle = BundleConverter.toBundle(params);
                processToNativeBundle(bundle);
                //targetDelegate.setArguments(BundleConverter.toBundle(params));
                targetDelegate.setArguments(bundle);

                ExtraTransaction extraTransaction = NavigationActivity.currentActivity.extraTransaction()
                        .setTag(pagePath);
                NavigationUtil.pushWithTransition(extraTransaction, transitionsConfig,
                        targetDelegate, animated, false);
                break;
            }
            case NavigationConstants.NATIVE_TAB_PAGE: {
                ExtraTransaction extraTransaction = NavigationActivity.currentActivity.extraTransaction()
                        .setTag(pagePath);
                NavigationUtil.pushWithTransition(extraTransaction, transitionsConfig,
                        NavigationBottomDelegate.newInstance(BundleConverter.toBundle(params)), animated, false);
                break;
            }
        }
    }

    @ReactMethod
    public void replaceStackTopRoute(final ReadableMap params, boolean animated) throws Exception {

        String pageType;
        String pagePath;
        String transitionsConfig;
        try {
            pageType = params.getString("pageType");
            pagePath = params.getString("pagePath");
            transitionsConfig = params.getString("transitionsConfig");
        } catch (Exception e) {
            return;
        }

        if (TextUtils.isEmpty(pageType) || TextUtils.isEmpty(pagePath)) {
            return;
        }

        switch (pageType) {
            case NavigationConstants.JS_PAGE: {
                ExtraTransaction extraTransaction = NavigationActivity.currentActivity.extraTransaction()
                        .setTag(pagePath);
                NavigationUtil.pushWithTransition(extraTransaction, transitionsConfig,
                        ReactFragment.newInstance(BundleConverter.toBundle(params)), animated, true);
                break;
            }
            case NavigationConstants.NATIVE_PAGE: {
                NavigationDelegate targetDelegate;
                try {
                    Class targetClass = Class.forName(pagePath);
                    targetDelegate = (NavigationDelegate) targetClass.newInstance();
                } catch (Exception e) {
                    e.printStackTrace();
                    return;
                }
                if (targetDelegate == null) {
                    return;
                }
                // processJsToNativeBundle(bundle);
                Bundle bundle = BundleConverter.toBundle(params);
                processToNativeBundle(bundle);
                //targetDelegate.setArguments(BundleConverter.toBundle(params));
                targetDelegate.setArguments(bundle);

                ExtraTransaction extraTransaction = NavigationActivity.currentActivity.extraTransaction()
                        .setTag(pagePath);
                NavigationUtil.pushWithTransition(extraTransaction, transitionsConfig,
                        targetDelegate, animated, true);
                break;
            }
            case NavigationConstants.NATIVE_TAB_PAGE: {
                ExtraTransaction extraTransaction = NavigationActivity.currentActivity.extraTransaction()
                        .setTag(pagePath);
                NavigationUtil.pushWithTransition(extraTransaction, transitionsConfig,
                        NavigationBottomDelegate.newInstance(BundleConverter.toBundle(params)), animated, true);
                break;
            }
        }
    }


    @ReactMethod
        public void pop(final boolean animated) {

            if (animated) {
                NavigationActivity.currentActivity.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        NavigationActivity.currentActivity.invokeDefaultOnBackPressed();
                    }
                });
            } else {
                List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
                int size = fragments.size();
                if (size <= 1) {
                    NavigationActivity.currentActivity.invokeDefaultOnBackPressed();
                    return;
                }

                NavigationActivity.currentActivity.extraTransaction()
                        .setCustomAnimations(R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim)
                        .remove((ISupportFragment) fragments.get(size - 1), true);
            }
        }

    @ReactMethod
    public void popToRoot(final boolean animated) {

        try {
            List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
            int size = fragments.size();
            if (size <= 1) {
                return;
            }

            ISupportFragment iSupportFragment = (ISupportFragment) fragments.get(0);

            if (animated) {
                NavigationActivity.currentActivity.getSupportDelegate().start(iSupportFragment, ISupportFragment.SINGLETASK);
            } else {
                NavigationActivity.currentActivity.getSupportDelegate().extraTransaction()
//                    .setCustomAnimations(R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim)
                        .start(iSupportFragment, ISupportFragment.SINGLETASK);
            }
        } catch (Exception ignored) {

        }

    }

    @ReactMethod
    public void popToRoute(final ReadableMap params, final boolean animated) {
        try {
            String uuid = params.getString("uniqueId");


            if (TextUtils.isEmpty(uuid)) {
                return;
            }

            List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
            int size = fragments.size();

            if (size <= 1) {
                return;
            }

            Fragment toFragment = findFragmentById(fragments, uuid);
            if (toFragment == null) {
                return;
            }

            NavigationActivity.currentActivity.getSupportDelegate().start((ISupportFragment) toFragment, ISupportFragment.SINGLETASK);

        } catch (Exception ignored) {
        }
    }

    @ReactMethod
    public void setTabBarSelectedIndex(final ReadableMap tabStack, final int newIndex) {

        String uuid;
        try {
            uuid = tabStack.getString("uniqueId");
        } catch (Exception e) {
            uuid = "";
        }

        if (TextUtils.isEmpty(uuid)) {
            return;
        }

        List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
        final Fragment targetFragment = findFragmentById(fragments, uuid);

        if (targetFragment instanceof NavigationBottomDelegate) {
            NavigationActivity.currentActivity.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    ((NavigationBottomDelegate) targetFragment).setNewIndex(newIndex);
                }
            });
        }
    }

    @ReactMethod
    public void isChildTab(final ReadableMap route, Promise promise) {
        if (route == null) {
            PromiseUtil.responseToJs(promise, false);
            return;
        }

        String uuid;
        try {
            uuid = route.getString("uniqueId");
        } catch (Exception e) {
            PromiseUtil.responseToJs(promise, false);
            return;
        }

        if (TextUtils.isEmpty(uuid)) {
            PromiseUtil.responseToJs(promise, false);
            return;
        }

        List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
        int size = fragments.size();
        for (int i = size - 1; i >= 0; --i) {
            Fragment current = fragments.get(i);
            if (current == null) {
                continue;
            }
            if (current instanceof NavigationBottomDelegate) {
                Fragment fragment = NavigationUtil.matchTabs((BaseBottomDelegate) current, uuid);
                if (fragment != null) {
                    PromiseUtil.responseToJs(promise, true);
                    return;
                }
            }
        }
    }

    @ReactMethod
    public void removeRoute(ReadableMap route, Promise promise) {
        try {
            String uuid = route.getString("uniqueId");

            if (TextUtils.isEmpty(uuid)) {
                return;
            }

            List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
            int size = fragments.size();

            if (size <= 1) {
                return;
            }

            Fragment toFragment = findFragmentById(fragments, uuid);
            if (toFragment == null) {
                return;
            }

//            NavigationActivity.currentActivity.extraTransaction()
//                    .setCustomAnimations(R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim, R.anim.pop_exit_no_anim)
//                    .remove((ISupportFragment) toFragment, false);
//            NavigationActivity.currentActivity.getSupportFragmentManager()
//            NavigationActivity.currentActivity.getSupportDelegate().popTo();

        } catch (Exception ignored) {
        }
    }

    @ReactMethod
    public void getRouteStack(Promise promise) {

        try {
            List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
            WritableArray writableArray = Arguments.createArray();

            int size = fragments.size();

            for (int i = 0; i < size; ++i) {

                Fragment currentFragment = fragments.get(i);

                if (currentFragment == null) {
                    continue;
                }

                WritableMap writableMap = Arguments.createMap();
                writableMap.putInt("index", i);
                writableMap.putString("pagePath", NavigationUtil.getPagePath(currentFragment));
                writableMap.putString("uniqueId", NavigationUtil.getPageUniqueId(currentFragment));
                writableMap.putString("pageType", NavigationUtil.getPageType(currentFragment));

                if (currentFragment instanceof NavigationBottomDelegate) {

                    WritableArray currentArray = Arguments.createArray();

                    List<Fragment> jsBridgeBottomFragments = ((NavigationBottomDelegate) currentFragment).getChildFragments();

                    int jsBridgeBottomSize = jsBridgeBottomFragments.size();
                    for (int j = 0; j < jsBridgeBottomSize; ++j) {
                        Fragment currentJsBridgeBottomFragment = jsBridgeBottomFragments.get(j);

                        WritableMap jsBridgeWritableMap = Arguments.createMap();
                        jsBridgeWritableMap.putInt("index", j);
                        jsBridgeWritableMap.putString("pagePath", NavigationUtil.getPagePath(currentJsBridgeBottomFragment));
                        jsBridgeWritableMap.putString("uniqueId", NavigationUtil.getPageUniqueId(currentJsBridgeBottomFragment));
                        jsBridgeWritableMap.putString("pageType", NavigationUtil.getPageType(currentJsBridgeBottomFragment));

                        currentArray.pushMap(jsBridgeWritableMap);
                    }

                    writableMap.putArray("tabs", currentArray);
                }

                writableArray.pushMap(writableMap);
            }

            if (promise != null) {
                promise.resolve(writableArray);
            }
        } catch (Exception ignored) {

        }

    }

    @ReactMethod
    public void showLaunchImageOnWindow(Promise promise) {
        SplashScreen.show(NavigationActivity.currentActivity, R.mipmap.splash_screen);
    }

    @ReactMethod
    public void removeLaunchImageFromWindow(Promise promise) {
        SplashScreen.hide(NavigationActivity.currentActivity);
    }

    @ReactMethod
    public void setTabBarItemBadgeValue(ReadableMap tabRoute, int tabIndex, String badgeValue) {
        try {
            String uuid = tabRoute.getString("uniqueId");

            if (TextUtils.isEmpty(uuid)) {
                return;
            }

            List<Fragment> fragments = NavigationActivity.currentActivity.getFragments();
            Fragment toFragment = findFragmentById(fragments, uuid);
            if (toFragment == null) {
                return;
            }

            if (toFragment instanceof BaseBottomDelegate) {
                ((BaseBottomDelegate) toFragment).setTabBarItemBadgeValue(tabIndex, badgeValue);
            }
        } catch (Exception ignored) {

        }

    }

    private Fragment findFragmentById(List<Fragment> fragments, String uuid) {
        if (fragments == null || TextUtils.isEmpty(uuid)) {
            return null;
        }
        int size = fragments.size();
        for (int i = size - 1; i >= 0; --i) {
            Fragment currentFragment = fragments.get(i);
            if (currentFragment == null) {
                continue;
            }

            if (currentFragment instanceof NavigationBottomDelegate) {
                try {
                    String uniqueId;
                    uniqueId = (String) ((NavigationBottomDelegate) currentFragment).setNavigationParams().get("uniqueId");
                    if (uuid.equals(uniqueId)) {
                        return currentFragment;
                    } else {
                        Fragment isMatchChild = findFragmentById(((BaseBottomDelegate) currentFragment).getChildFragments(), uuid);
                        if (isMatchChild != null) {
                            return currentFragment;
                        }
                    }
                } catch (Exception ignored) {
                }
            }

            if (currentFragment instanceof ReactItemContainer) {
                String uniqueId;
                ISupportFragment child = SupportHelper.getTopFragment(currentFragment.getChildFragmentManager());
                if (child instanceof ReactItem) {
                    try {
                        uniqueId = (String) ((ReactItem) child).setNavigationParams().get("uniqueId");
                        if (uuid.equals(uniqueId)) {
                            return currentFragment;
                        }
                    } catch (Exception ignored) {
                    }
                }
            }

            if (currentFragment instanceof NavigationDelegate) {
                String uniqueId = ((NavigationDelegate) currentFragment).getJsId();
                if (uuid.equals(uniqueId)) {
                    return currentFragment;
                }
            }

            if (currentFragment instanceof ReactDelegate) {
                try {
                    String uniqueId = (String) ((ReactDelegate) currentFragment).setNavigationParams().get("uniqueId");
                    if (uuid.equals(uniqueId)) {
                        return currentFragment;
                    }
                } catch (Exception ignored) {
                }
            }
        }

        return null;
    }

    /**
     * 处理从Js页面跳到Native页面 存在 需要传递回调函数的情况
     *
     * @param bundle
     */
    private void processToNativeBundle(Bundle bundle) {

        if (bundle != null) {
            try {
                Bundle paramsBundle = bundle.getBundle(PARAMS);
                Bundle clickCallBackBundle = paramsBundle.getBundle(CLICK_CALLBACK);
                final String callBackID = clickCallBackBundle.getString(CALLBACK_ID);
                callBackIDSet.add(callBackID);

                /**
                 * 测试使用的代码，延迟5秒弹出一个alert dialog
                 */
                if (BuildConfig.DEBUG) {
                    mExecutorService.schedule(new Runnable() {
                        @Override
                        public void run() {
                            ReactContext mReactCtx = getReactApplicationContext();
                            //mReactInstanceManager.getCurrentReactContext();
                            WritableMap writableMap = Arguments.createMap();
                            WritableMap params = Arguments.createMap();
                            params.putString("xg", "fuck");
                            writableMap.putMap(PARAMS, params);
                            writableMap.putString(CALLBACK_ID, callBackID);
                            NativeNavigationEmitter.sendEvent(mReactCtx, writableMap);
                        }
                    }, 5000, TimeUnit.MILLISECONDS);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @ReactMethod
    public void alert(final ReadableMap alertConfig) {
        NavigationUtil.alert(alertConfig);
    }

    /**
     * dismiss alert
     *
     * @param alertId
     */
    @ReactMethod
    public void removeAlert(String alertId) {
        NavigationUtil.removeAlert(alertId);
    }

    @ReactMethod
    public void alertIsShow(String alertId, Promise promise) {
        promise.resolve(NavigationUtil.alertIsShow(alertId));
    }

}
